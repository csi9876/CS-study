# 메모리 관리

### 논리적 주소

- 프로세스마다 독립적으로 가지는 주소 공간

- 각 프로세스마다 0으로 시작

- CPU가 보는 주소는 논리적 주소

### 물리적 주소

- 메모리에 실제로 올라가는 위치

    

###### 주소 바인딩

- Symbolic Address → Logical Address (시점)→ Physical Address

##### Compile time binding

- 물리적 메모리 주소가 컴파일 시 알려짐

- 시작 위치 변경시 재컴파일

- 컴파일러는 절대 코드 생성

#### Load time binding

- Loader의 책임 하에 물리적 메모리 주소가 부여

- 컴파일러가 재배치 코드를 생성한 경우

##### Execution time binding (Runtime binding )

- 수행이 시작된 이후에도 프로세스의 메모리 상 위치를 옮길 수 있음

- cpu가 주소를 참조할 때마다 binding을 점검(address mapping table)

- 하드웨어적인 지원이 필요

    

    

### MMU(Memory-Management Unit)

- 논리적 주소를 물리적 주소로 매핑해주는 하드웨어

- MMU scheme : 사용자 프로세스가 cpu에서 수행되며 생성해내는 모든 주소값에 대해 base register(=relication register)의 값을 더한다

- user program : 논리적 주소만을 다룬다

    

### 동적 로딩 (dynamic)

- 프로세스 전체를 메모리에 미리 다 올리는 것이 아니라 해당 루틴이 불려질 때 메모리에 load하는 것

- Memory Utilization의 향상

- 가끔식 사용되는 많은 양의 코드의 경우 유용

- 운영체제의 특별한 지원 없이 프로그램 자체에서 구현 가능

- Loading : 메모리로 올리는것

    

### overlays

- 메모리에 프로세스의 부분 중 실제 필요한 정보만을 올리는 기법이다.

- 프로세스의 크기가 메모리보다 클 때 유용하다

- 운영체제의 지원없이 사용자에 의해 구현

- 작은 공간의 메모리를 사용하던 초창기 시스템에서 운영체제의 지원 없이 수작업으로 프로그래머가 구현하였다. (manual overlay)

cf)동적 로딩과의 차이점

- 동적 로딩: 다중 프로세스 환경에서 메모리에 더 많은 프로세스를 동시에 올려놓고 실행하기 위한 용도이다.
- 오버랩: 단일 프로세스만을 메모리에 올려놓는 환경에서 메모리 용량보다 큰 프로세스를 올리기 위한 어쩔 수 없는 선택이다.

    

### Swapping (스와핑)

- 메모리에 올라온 프로세스의 주소 공간 전체를 디스크의 backing store로 쫓아내는 것이다.

- backing store(swap area)
  
  - 디스크 : 많은 사용자의 프로세스 이미지를 담을 만큼 충분히 빠르고 큰 저장 공간

- swap이 일어나는 과정
  
  일반적으로 중기 스케줄러가 swap out할 프로세스를 선정한다.
  
  - 우선 순위 기반 CPU 스케줄링
  - 우선 순위가 낮은 프로세스를 swap out함.
  - 우선 순위가 높은 프로세스를 swap in함.

- 컴파일 타임 바인딩 혹은 로드 타임 바인딩에서는  원래 메모리 위치로 다시 swap in.

- 실행시간 바인딩에서는 빈 메모리 영역 아무데나 올릴 수 있음

- swap time은 대부분 transfer time(swap되는 양에 비례하는 시간)임

    

    

### dynamic linking(동적연결)

- 연결을 실행시간까지 미루는 기법

- static
  
  - 라이브러리가 프로그램의 실행 파일 코드에 포함
  
  - 실행 파일의 크기가 커짐
  
  - 동일한 라이브러리를 각각의 프로세스가 메모리에 올려 메모리 낭비

- dynamic
  
  - 라이브러리가 실행 시 연결
  
  - 라이브러리 호출 부분에 라이브러리 루틴의 위치를 찾기 위한 stub이라는 작은 코드를 둠
  
  - 라이브러리가 이미 메모리에 있으면 그 루틴의 주소로 가고, 없으면 디스크에서 읽어 옴
  
  - 운영체제의 도움이 필요

    

    

#### 물리적 메모리의 할당 방식

- 영역
  
  - OS 상주 영역 : 낮은 영역
  
  - 사용자 프로세스 영역 : 높은 영역

- 사용자 프로세스 할당 방법
  
  - 연속할당
    
    - 각각의 프로세스가 메모리의 연속적인 공간에 적재
  
  - 불연속 할당
    
    - 하나의 프로세스가 메모리의 여러 영역에 분산되어 올라갈 수 있음
    
    - paging

    

#### 고정분할

- 물리적 메모리를 몇개의 영구적 분할로 나눔

- 분할의 크기가 모두 동일한 방식과 서로 다른 방식 존재

- 분할당 하나의 프로그램 적재

- 융통성이 없음
  
  - 동시에 메모리에 load되는 프로그램의 수 고정
  
  - 최대 수행 가능 프로그램 크기 제한
  
  - internal fragmentation과 external fragmentation 발생

    

#### 가변분할

- 프로그램의 크기를 고려해서 할당

- 분할의 크기, 개수가 동적으로 변함

- 기술적 관리 기법 필요

- external fragmentation 발생

    

#### Hole

- 가용 메모리 공간

- 다양한 크기의 홀들이 메모리 여러 곳에 흩어져 있음

- 프로세스가 도착하면 수용가능한 홀을 할당

- 운영체제는 다음의 정보를 유지
  
  - 할당 공간, 

    

#### 동적메모리 할당

- 가변 분할 방식에서 size n 인 요청을 만족하는 가장 적절한 hole를 찾는 문제

- first fit : size가 n이상인 것 중 최초로 찾아지는 홀에 할당

- Best-fit
  
  - size가 n 이상인 가장 작은 hole을 찾아서 할당
  - Hole들의 리스트가 크기 순으로 정렬되지 않은 경우 모든 hole을 탐색
  - 많은 수의 아주 작은 hole이 생성

- Worst-fit
  
  - 가장 큰 hole에 할당
  - 역시 hole을 탐색
  - 상대적으로 아주 큰 hole이 생성

- First-fit과 Best-fit이 Worst-fit보다 속도와 공간 이용률 측면에서 효과적

    

#### Compaction (압축)

- 외부조각 문제를 해결하는 방법

- 사용 중인 메모리 영역을 한군데로 몰고 홀들을 다른 한 곳으로 몰아 큰 블럭을 만드는 것

- 매우 비용이 많이 든다

- 최소한의 메모리 이동으로 압축하는 방법

- 압축은 프로세스의 주소가 실행 시간에 동적으로 재배치가 가능한 경우 지원하는 환경

    

### 불연속 할당

- 페이징

- 세그멘테이션

    

#### 페이징

- 프로세스의 가상메모리를 동일한 사이즈의 페이지 단위로 나눔

- 가상 메모리 내용이 페이지 단위로 noncontiguous하게 저장

- 일부는 backing storage, 일부는 물리적 메모리에 저장

- 기본 방법
  
  - 물리적 메모리를 동일한 크기의 프레임으로 나눔
  
  - 논리적 메모리를 동일 크기의 페이지로 나눔
  
  - 모든 가용 프레임들을 관리
  
  - 페이지 테이블을 사용해 논리적 주소를 물리적 주소로 변환
  
  - 내부 조각 발생 가능성

    

#### 페이지 테이블의 실행

- 페이지 테이블은 메인 메모리에 상주

- ptbr은 페이지 테이블을 가리킴, 테이블 크기를 보관

-  모든 메모리 접근 연산에는 2번의 메모리 접근이 필요

- 페이지 테이블 접근 1번, 데이터/인스트럭션 접근 1번

- 속도향상을 위해 : TLB 혹은 associative register이라 불리는 고속의 하드웨어 캐시사용

    

### TWO LEVEL PAGE TABLE

- 주소  공간이 매우 큰 프로그램을 지원

- 32비트 사용시 4G 주소공간 : 페이지 사이즈가 4K라면, 한 프로세스당 페이지 테이블을 위해 1M 크기의 페이지 테이블 ENTRY 필요

- 대부분의 프로그램은 4G의 주소 공간 중 지극히 일부분만 사용하므로 페이지 테이블 공간이 심하게 낭비

- 페이지 테이블 자체를  페이지로 구성

    

#### 다단계 페이지 테이블

- 주소 공간이 더 커지면 다단계 페이지 필요

- 각 단계의 페이지 테이블이 메모리에 존재하므로 논리적 주소의 물리적 주소 변환에 더 많은 메모리 접근 필요

- TLB를 통해 접근 시간을 줄일 수 있음

    

#### 메모리 protection

- 페이지 테이블의 각 엔트리마다 아래의 비트를 둔다

- protection bit : 페이지에 대한 접근 권한

- valid_invalid bit
  
  - 유효는 해당 주소의 프레임에 그 프로세스를 구성하는 유효한 내용이 있음, 접근허용
  
  - 무효는 유효한 내용이 없음, 접근 불허

    

### inverted page table

- 페이지 테이블이 큰 이유
  
  - 모든 프로세스 별로 논리적 주소에 대응하는 모든 페이지에 페이지 테이블 엔트리가 존재
  
  - 대응하는 페이지가 메모레에 있든 아니든 페이지 테이블에는 엔트리로 존재

- 역방향 페이지
  
  - 페이지 프레임 하나당 페이지 테이블에 하나의 엔트리를 둔 것
  
  - 각 페이지 테이블 엔트리는 각각의 물리적 메모리의 페이지 프레임이 담고 있는 내용 표시
  
  - 단점 : 테이블 전체를 탐색하야 함 > 연관 레지스터로 병렬 탐색

    

### 공유 페이지

- 공유 코드

- re-entreant code : 읽기 전용, 프로세스 간에 하나의 코드만 메모리에 올림

- 공유 코드는 모든 프로세스의 논리적 주소에 동일한 위치에 있어야 함

- 사유 코드와 데이터 : 각 프로세스들은 독자적으로 메모리에 올림

- 사유 데이터는 논리적 주소의 아무 곳에 와도 무방

    

#### segmentation

- 프로그램은 의미 단위인 여러 개의 세그먼테이션으로 구성  

-  프로그램을 구성하는 하나 하나를 세그먼트

- 프로그램 전체를 하나의 세그먼트로 정의

    

### 세그먼트 기법

- 논리적 주소 : 세그먼트-넘버 + 오프셋

- 세그먼트 테이블
  
  - base : 시작 물리적 주소
  
  - limit : 세그먼트의 길이

- STBR : 물리적 메모리에서 세그먼트 테이블의 위치

- STLR : 프로그램이 사용하는 세그먼트 수

- 보호
  
  - 각 세그먼트 별로 프로텍션 비트가 있음 

- 공유
  
  - 세그먼트 공유
  
  - 같은 세그먼트 넘버

- allocation
  
  - 세그먼트 길이가 균일하지 않으므로 가변분할 방식과 동일한 문제점 발생
