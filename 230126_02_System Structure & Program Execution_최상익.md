### 컴퓨터 시스템 구조

- ##### 컴퓨터
  
  - cpu
    
    - 레지스터 : 메모리보다 빠르고 작은 저장공간
    
    - 모드 비트 : cpu에서 실행하는 것이 운영체제인지 사용자 프로그램인지 구분
    
    - 인터럽트 라인 : 계속 인스트럭션을 실행하고 있기 때문에 IO device의 요청이 들어왔을 때 인터럽트가 신호를 줌 > OS가 작업을 멈추고 CPU를 IO디바이스에 할당
    
    - timer : 특정 프로그램이 cpu를 독점하지 못하게 함
  
  - memory(cpu의 작업공간) : cpu는 매순간 메모리에서 기계어를 읽어서 실행
  
  - DMA controller
    
    - DMA도 메모리에 접근가능
    
    - 인터럽트가 너무 많이 발생하면 cpu가 방해를 받으므로 대신 I/O device의 신호를 받음

*mode bit

- 사용자 프로그램의 잘못된 수행으로 다른 프로그램 및 운영체제에 피해가 가지 않도록 하기 위한 보호 장치

- mode bit을 통해 하드웨어적으로 두가지 모드의 operation 지원

- 1 : 사용자모드 : 사용자 프로그램 수행

- 0 : 모니터 모드 : OS 코드 수행  (커널모드, 시스템 모드)
  
  - 보안을 해칠 수 있는 중요한 명령어는 모니터 모드에서만 수행가능한 특권명령으로 규정
  
  - interrupt나 exception 발생시 하드웨어가 0으로 바꿈
  
  - 사용자 프로그램에게 CPU를 넘기기 전에 1로 세팅

    *타이머

- 정해진 시간이 흐른 뒤 운영체제에게 제어권이 넘어가도록 인터럽트를 발생시킴

- 타이머는 매 클럭 틱 때마다 1씩 감소

- 타이머 값이 0이 되면 타이머 인터럽트 발생

- CPU를 특정 프로그램이 독점하는 것으로부터 보호

- 타이머는 time sharing을 구현하기 위해 널리 이용

- 타이머는 현재 시간을 계산하기 위해서도 사용

ㅡ

- ##### I/O device
  
  - disk : 보조기억장치, I/O device
  
  - local buffer : controller들의 작업공간, 메모리 역할
  
  - controller : 각각의 I/O들 옆에서 디바이스를 전담하는 작은 cpu의 역할 수행

*I/O device controller

- 해당 IO 장치유형을 관리하는 일종의 작은 cpu

- 제어 정보를 위해 control register, status register을 가짐

- local buffer을 가짐(일종의 data register)

- I/O는 실제 디바이스와 로컬 버퍼 사이에서 일어남

- 디바이스 컨트롤러는 I/O가 끝났을 경우 인터럽트로 CPU에 그 사실을 알림

cf)device driver : 장치구동기 : OS 코드 중 각 장치별 처리루틴 > software

    device controller : 장치제어기 : 각 장치를 통제하는 일종의 작은 CPU > hardware

### 입출력(I/O)의 수행

- 모든 입출력 명령은 특권 명령

- 사용자 프로그램은 어떻게 I/O를 하는가
  
  - 시스템 콜 : 사용자 프로그램은 운영체제에 I/O 요청, cpu에 인터럽트를 건다
  
  - trap을 사용하여 인터럽트 벡터의 특정 위치로 이동
  
  - 제어권이 인터럽트 벡터가 가리키는 인터럽트 서비스 루틴으로 이동
  
  - 올바른 I/O 요청인지 확인 후 I/O 수행
  
  - I/O 완료 시 제어권을 시스템콜 다음 명령으로 옮김

### 인터럽트

- 인터럽트 당한 시점의 레지스터와 program counter을 저장한 후 CPU의 제어를 인터럽트 처리 루틴에 넘긴다

- 좁은의미 : 하드웨어 인터럽트 : 하드웨어가 발생시킨 인터럽트
  
                          I/O가 종료시 CPU에 신호

- 넓은의미 :  Trap(소프트웨어 인터럽트)
  
                     I/O가 필요 시 CPU에 신호
  
  - Exception : 프로그램이 오류를 범한 경우
  
  - System call : 프로그램이 커널 함수를 호출한 경우

- 인터럽트 벡터 : 해당 인터럽트의 처리 루트를 가지고 있음

- 인터럽트 처리 루틴 : 해당 인터럽트를 처리하는 커널 함수

*현대의 운영체제는 인터럽트에 의해 구동

## 동기식 입출력 ( synchronous)

- I/O 요청 후 <u>입출력 작업이 완료된 후에야 제어가 사용자 프로그램에 넘어감</u>

- I/O요청 > 제어권과 동시에 완료 인터럽트  : 작업의 결과를 보고 제어

- 구현방법 1 : 하나의 I/O장치만 대기, CPU 낭비
  
  - I/O가 끝날 때까지 CPU를 낭비시킴
  
  - 매시점 하나의 I/O만 일어날 수 있음

- 구현방법 2 : 여러 I/O 장치 실행 가능, CPU도 계속 작업
  
  - I/O가 완료될 떄까지 해당 프로그램에게서 CPU를 빼앗음
  
  - I/O 처리를 기다리는 줄에 그 프로그램을 줄 세움
  
  - 다른 프로그램에게 CPU를 줌

## 비동기식 입출력

- I/O가 시작된 후 입출력 작업이 끝나기를 기다리지 않고 <u>제어가 사용자 프로그램에 즉시 </u>넘어감

- I/O요청 > 제어권 > 완료 인터럽트  : 작업의 결과를 볼 필요가 없는 경우

- *동기식과 비동기식 두 경우 모두 I/O의 완료는 인터럽트로 알려줌

#### DMA

- 빠른 입출력 장치를 메모리에 가까운 속도로 처리하기 위해 사용

- 인터럽트가 너무 많이 발생하면 cpu가 방해를 받으므로 DMA가 대신 I/O device의 신호를 받아서 모아서 전달

- CPU의 중재 없이 디바이스 컨트롤러가 디바이스의 버퍼 스토리지의 내용을 메모리에 block 단위로 직접 전송

- 바이트 단위가 아니라 block 단위로 인터럽트를 발생시킴

### 서로 다른 입출력 명령어

- 일반적인 I/O 방식
  
  - I/O를 수행하는 special instruction에 의해

- memory mapped에 의해 , 메모리에서수행

## 저장장치의 계층 구조

- primary (휘발성) : cpu가 직접 접근 가능(바이트 단위 접근 가능)
  
  - 레지스터
  
  - 캐시 메모리
  
  - 메인 메모리

- secondary(비휘발성) : cpu가 직접 접근하여 처리 불가능
  
  - 마그네틱 디스크
  
  - 옵티컬 디스크
  
  - 마그네틱 테이프

*상단으로 갈수록 speed가 빠르고, cost가 비싸다, volatility(휘발성)이다

## 프로그램의 실행(메모리 load)

- file system : 실행파일

- virtyal memory : 프로그램마다 독자적인 주소공간

- physical memory : 물리적인 메모리에 주소공간의 필요한 부분들만 올려서 실행

ex) 실행파일 > address space(stack/data/code) > 일부만 물리적 메모리로 이동

### 커널 주소 공간의 내용

- code
  
  - 시스템콜, 인터럽트 처리 코드
  
  - 자원관리를 위한 코드
  
  - 편리한 서비스 제공을 위한 코드

- data
  
  - cpu, mem, disk, pcb 

- stack
  
  - process의 커널 스택

### 사용자 프로그램이 사용하는 함수

함수

- 사용자 정의함수   >> process의 address space
  
  - 자신의 프로그램에서 정의한 함수

- 라이브러리 함수  >> process의 address space
  
  - 자신의 프로그램에서 정의하지 않고 갖다 쓴 함수
  
  - 자신의 프로그램의 실행 파일에 포함되어 있다

- 커널함수  >> 커널의 address space
  
  - 운영체제 프로그램의 함수
  
  - 커널 함수의 호출 = 시스템 콜

### 프로그램의 실행

A의 주소공간 : user mode

커널의 주소공간 : kernel mode

A의 주소공간 : 유저 모드

커널의 주소공간 : 커널 모드

반복
