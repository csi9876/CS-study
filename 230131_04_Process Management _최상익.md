### 프로세스 생성

- copy in write(cow) : 부모의 것을 공유하고 있다가 수정이 발생하면 복사

- 부모 프로세스가 자식 프로세스를 생성

- 프로세스의 트리(계층 구조) 형성

- 프로세스는 자원을 필요로 함
  
  - 운영체제로부터 받는다
  
  - 부모와 공유한다

- 자원의 공유
  
  - 부모와 자식이 모든 자원을 공유하는 모델
  
  - 일부를 공유하는 모델
  
  - 전혀 공유하지 않는 모델

- 수행(execution)
  
  - 부모와 자식은 공존하며 수행되는 모델
  
  - 자식이 종료될 때까지 부모가 기다리는 모델

#### 생성 방법

- 주소공간
  
  - 자식은 부모의 공간을 복사함 (binary and OS data)
  
  - 자식은 그 공간에 새로운 프로그램을 올림

- 유닉스의 예
  
  - <u>fork ()</u>: 시스템 콜이 새로운 프로세스를 생성
    
    - 부모를 그대로 복사 (OS data except pid)
    
    - 주소 공간 할당
  
  - fork 다음에 이어지는 <u>exec()</u> 시스템콜을 통해 새로운 프로그램을 메모리에 올림

    

#### 프로세스 종료

- 프로세스가 마지막 명령을 수행한 후 운영체제에게 이를 알려줌(exit)
  
  - 자식이 부모에게 output 데이터를 보냄(via wait)
  
  - 프로세스의 각종 자원들이 운영체제에게 반납됨

- 부모 프로세스가 자식의 수행을 종료시킴(abort)
  
  - 자식이 할당 자원의 한계치를 넘어섬
  
  - 자식에게 할당된 태스크가 더 이상 필요하지 않음
  
  - 부모가 종료 하는 경우
    
    - 운영체제는 부모 프로세스가 종료하는 경우 자식이 더 이상 수행되도록 두지 않는다.
    
    - 단계적인 종료

        

프로세스와 관련한 네가지 주요 시스템콜

### fork() 시스템 콜 (자식을 복제 생성)

- 부모와 자식을 확인하기 위해 : <u>parent code : pid > 0</u>  , child process : pid = 0

- 자식 프로세스도 복제된 이후 부모가 이미 실행한 pork 이전이 아닌 이후부터 실행

```
int main()
{ int pid;
printf("\n Hello, i am child!\n"); pid = fork();
if(pid == 0) /*this is child */ printf("\n Hello, i am child!\n");
else if(pid>o) /* this is parent */ printf("\n Hello, I am parent!\n");}
```

### exec() 시스템 콜 (새로운 프로그램으로 덮어 씌우기)

- execlp() :자식프로그램은 해당 함수를 만나고 <u>새로운 프로그램</u>으로 덮어 씌워지며 처음부터 시작, 새로운 프로그램으로 시작하며 다시 돌아갈 수 없다.
- 반드시 자식을 만날 필요는 없다, 일반 프로그램도 해당 함수를 만나면 동일하게 기능
- exec 이후의 코드는 영원히 실행할 수 없는 코드

```
int main()
{ int pid;
printf("\n Hello, i am child!\n"); pid = fork();
if(pid == 0) /*this is child */ printf("\n Hello, i am child!\n");
    execlp("/bin/data", "/bin/data", (char*)0)"
     printf("\n Hello, i am child!\n")
else if(pid>o) /* this is parent */ printf("\n Hello, I am parent!\n");}
```

```
int main()
printf("1");   (실행 파일 2번 호출/ 명령/ char은 0)
execlp("echo", "echo", "hello", "3", (char*)0);
printf("2");}
*해당코드는 1 출력 3출력 2는 출력하지 않고 실행중지
```

### wait() 시스템콜 (부모가 자식이 종료될 때 까지 대기)

- 프로세스 A가 wait()시스템 콜을 호출하면   (부모가 자식이 종료될 때까지 대기)
  
  - 커널은 child가 종료될 때까지 프로세스 A를 sleep시킨다 (block 상태)
  
  - child proces가 종료되면 커널은 프로세스A를 깨운다 (ready 상태)

    

### exit() 시스템 콜 (프로세스 종료)

프로세스의 종료

- 자발적 종료
  
  - 마지막 statement 수행 후 exit() 시스템 콜을 통해
  
  - 프로그램에 명시적으로 적어주지 않아도 main 함수가 리턴되는 위치에 컴파일러가 넣어줌

- 비자발적 종료
  
  - 부모 프로세스가 자식 프로세스를 강제 종료시킴
    
    - 자식 프로세스가 한계치를 넘어서는 자원 요청
    
    - 자식에게 할당된 태스크가 더 이상 필요하지 않음
  
  - 키보드로 kill, break를 친 경우
  
  - 부모가 종료하는 경우
    
    - 부모 프로세스가 종료하기 전에 자식들이 먼저 종료됨

    

    

#### 프로세스 간 협력

- 독립적 프로세스
  
  - 프로세스는 각자의 주소공간을 가지고 수행되므로 원칙적으로 하나의 프로세스는 다른 프로세스의 수행에 영향을 미치지는 못함

- 협력 프로세스
  
  - 프로세스 협력 메커니즘을 통해 하나의 프로세스가 다른 프로세스의 수행에 영향을 미칠 수 있음

- 프로세스 간 협력 메커니즘(IPC)
  
  - 메시지를 전달하는 방법 (message passing) : 커널을 통해 메시지를 전달
  
  - 주소공간을 공유하는 방법(shared memory) : 서로 다른 프로세스 간에도 일부 주소공간을 공유하게 하는 shared memory메커니즘이 있음(커널에게 미리 전달해야함, 커널의 승인 이후에는 알아서)

cf) 스레드 : 하나의 프로세스 안에 여러 수행단위가 있는 것, 프로세스 간 협력은 아니다

    

    

#### 메시지 패싱

- 메시지 시스템 : 프로세스 사이에 공유변수를 일체 사용하지 않고 통신하는 시스템

- 1)direct cummunication : 통신하려는 프로세스의 이름을 명시적으로 표시
  
  - 프로세스 Q가 프로세스 P에게 전달

- 2)indirect cummunication : 메일박스 또는 port를 통해 메시지를 간접 전달
  
  - 프로세스가 메일박스에 넣고 다른 프로세스가 받음(누가 받을지는 모른다)

    

    
