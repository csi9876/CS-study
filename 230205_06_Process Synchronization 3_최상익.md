#### 데이터 접근

- data > 연산할 data > 연산 > 연산결과

- storage box : 데이터 저장(주소공간, 메모리) > execution box : 데이터 연산(프로세스, cpu)

        

    

#### race condition (경쟁 상태)

- s-box를 공유하는 e-box가 여럿 있는 경우 race condition의 가능성이 있음

- 데이터를 여러 군데에서 가져가서 최신화하지 않은 데이터를 가져감

- cpu가 하나고 프로세스 각자가 주소공간을 가지기 때문에 보통은 발생X

- cpu가 여럿인 시스템

- 공유메모리를 사용하는 프로세스들

- 커널 내부 데이터를 접근하는 루틴들 간(커널모드 수행 중 인터럽트로 커널모드 다른 루틴 수행)

- ex) 커널모드 러닝 중 인터럽트가 발생하여 인터럽트 처리루틴이 수행
  
  - 양쪽  다 커널 코드이므로 커널 주소 공간을 공유
  
  - ->해결책 : 중요한 작업 중에는 인터럽트가 와도 전환하지 않는다

- 프로세스가 시스템 콜을 하여 커널모드 수행중인데 문맥교환 발생
  
  - 두 프로세스 간 주소공간 간에는 공유메모리 없음 -> 시스템 콜을 하는 동안에는 커널 주소 공간의 데이터를 공유하게 된다
    
    - -> 해결책 : 커널모드 수행 중에는 cpu를 preempt하지 않음 커널모드에서 사용자 모드로 돌아갈 때 preempt

- 멀티프로세서에서 공유메모리 내의 커널 데이터
  
  - cpu가 여럿인 환경 : 인터럽트를 대기시키는 방법으론 해결 불가능
    
    - 한번에 하나의 cpu만 커널에 들어갈 수 있게 하는 방법 > 비효율적
    
    - 커널 내부에 있는 각 공유 데이터에 접근할 때마다 그 데이터에 대한 lock/unlock을 하는 방법

    

#### process synchronization 문제

- 공유 데이터의 동시 접근은  데이터의 불일치 문제를 발생시킬 수 있다

- 일관성 유지를 위해서는 협력 프로세스 간의 실행 순서를 정해주는 메커니즘 필요

- reace condition
  
  - 여러 프로세스들이 동시에 공유데이터에 접근하는 상황
  
  - 데이터의 최종 연산 결과는 마지막에 그 데이터를 다룬 프로세스에 따라 달라짐
  
  - 해결책 : concurrent process는 동기화 되어야 한다

    

#### critical section

- 공유데이터에 접근하는 코드

- 문제 : 하나의 프로세스가 크리티컬 섹션에 있을 때 다른 모든 프로세스는 들어갈 수 없어야 한다.

### 프로그램적 해결법의 충족 조건

- mutual exclusion(상호 배제)
  
  - 프로세스 pi가 크리티컬 섹션 부분을 수행 중이면 다른 모든 프로세스들은 그들의 크리티킬 섹션에 들어가면 안 된다

- progress(진행)
  
  - 아무도 크레티컬 섹션에 있지 않은 상태에서 크리티컬 섹션에 들어가고자 하는 프로세스가 있으면 들어가게 해주어야 한다

- bounded waiting(유한 대기)
  
  - 프로세스가 크리티컬 섹션에 들어가려고 요청한 후부터 그 요청이 허용될 때까지 다른 프로세스들이 들어가는 횟수에 한계가 있어야 한다

    

### initial attempts to solve problem

### 알고리즘 1

- turn이 0이면 나의 차례

- 턴이 0이 아니면 while에서 반복하다가 0을 바뀌면 크리티컬 섹션에 들어가 수행, 수행이 끝나면 턴을 1로 바꿔줌

- 아무도 크리티컬 섹션에 없어도 들어가지 않는 문제가 발생(진행 충족X)

### 알고리즘 2

- flag가 true면 크리티컬 섹션에 들어가고 한다는 의사표현

- 플래그를 1로 바꿔 자신의 의사표시, 다른 프로세스가 1이면 대기, 수행 후 0으로 바뀜

- 둘 다 끊임없이 양보하는 상황이 발생할 가능성 존재 (진행 충족X)

### 알고리즘 3

- flag와 turn을 모두 사용, 상대방의 flag가 1이고 턴도 상대방의 차례인 1인 상태면 대기, 아니면 자신이 들어간다

- busy waiting(spin lock) : 계속 cpu와 메모리를 쓰면서 기다린다.(계속 while문을 돌면서 cpu를 사용한다.)

    

### 동기화 하드웨어

- 하드웨어적으로 test&modify를 atomic하게 수행할 수 있도록 지원하는 경우 앞의 문제는 간단히 해결

- test&set : 크리티컬 섹션을 읽고 락이 걸려있으면 안 들어감, 락이 안 걸려있으면 락을 걸고 내가 들어감

### Semaphores

- 앞의 방식들을 추상화시킴

- 아래의 두가지 atomic 연산에 의해서만 접근 가능

- P(s) : 세마포어 변수를 획득하는 연산 : s값이 자원 5고 p연산을 하면 1개씩 가져감

- V(S) : 변수를 사용하고 반납하는 과정 :  자원을 사용하고 다시 되돌려놓음

크리티컬 섹션에 세마포어를 적용하면

- 들어갈 땐 p연산 나올 땐 v연산 수행

-  busy wait 문제 발생 : 자원이 0 이면 계속 연산 순환 (spin lock)

- block & wakeup 방식 구현(sleep lock)

### block wakeup

- block : 커널은 block를 호출한 프로세스를 서스펜드 시킴, 이 프로세스의 PCB를 세마포어에 대한 wait q에 넣음

- wakeup(P) : block된 프로세스P를 wakeup시킴, 이 프로세스의 PCB를 ready q로 옮김

<img src="asd_assets/2023-02-05-19-03-44-image.png" title="" alt="" width="459">    

s값이 음수면 block : 모든 자원을 내놓음

그 이후에도 음수면 대기하는 프로세스가 없으므로 잠들어 있는 프로세스 하나를 깨워줌    

cf)

busy wait vs block wakeup

- 크리티컬 섹션의 길이가 긴 경우 후자가 적당, 일반적으로는 후자가 더 좋음

- 길이가 매우 짧은 경우 후자의 오버헤드가 더 클 수도 있음

    

    

### 세마포어 two type

- counting semaphorre
  
  - 도메인이 0 이상인 임의의 정수값
  
  - 주로 자원 counting에 이용

- binary semaphore (mutex)
  
  - 0 또는 1 값만 가질 수 있는 세마포어
  
  - 주로 mutual exclusion (lock/unlock)에 사용

    

    

### deadlock and starvation

- deadlock : 둘 이상의 프로세스가 서로 상대방에 의해 충족될 수 있는 이벤트를 무한히 기다리는 현상
  
  ![](asd_assets/2023-02-05-19-09-38-image.png)
  
  ->자원을 획득하는 순서를 설정해주면 해결(q를 획득하려면 s를 획득해야 가능하게 설정)

- starvation : indefinite blocking : 프로세스가 서스펜드된 이유에 해당하는 세마포어 큐에서 빠져나갈 수 없는 현상

    

### 세마포어 문제

#### bounded buffer 문제

- 버퍼의 크기가 유한

- 프로듀서-컨슈머 여럿 존재

- 생산자
  
  - empty 버퍼가 있나요(없으면 기다림)
  
  - 공유데이터에 lock를 건다
  
  - 빈 버퍼에 데이터 입력 및 조작
  
  - lock를 푼다
  
  - 풀 버퍼 하나 증가

- 소비자
  
  - full 버퍼가 있나요(없으면 기다림)
  
  - 공유데이터에 lock를 건다
  
  - 풀버퍼에서 데이터를 꺼내고 조작
  
  - lcok를 푼다
  
  - 빈 버퍼 하나 증가

- shared buffer :버퍼 자체 및 버퍼 조작변수 : 락을 걸고 풀 때 세마포어 변수 사용

- 동기화 다양성
  
  - mutual exclusion
  
  - resource count
  
  ![](asd_assets/2023-02-05-19-22-50-image.png)

        

### readres writers 문제

- 한 프로세스가 db에 write 중일 때 다른 프로세스가 접근하면 안 됨

- read는 여럿이 동시에 해도 됨

- 해결 
  
  - writer가 db에 접근 허가를 얻지 못한 상태에서는 모든 대기중인 reader들을 다 db에 접근하게 해준다
  
  - writer는 대기 중인 reader가 하나도 없을 때 db접근이 허용된다
  
  - 이미 writer가 db에 접근 중이면 reader들은 접근이 금지된다
  
  - writer가  db에서 빠져나가야  reader 접근 가능

- shared data
  
  - DB 자체
  
  - readcount(현재 db에 접근중인 reader의 수)

- 동기화 변수
  
  - mutex : 공유변수 리드카운트를 접근하는 코드의 mutual exclusion 보장
  
  - DB : 공유 db 자체를 올바르게 접근하게 하는 역할

<img src="asd_assets/2023-02-05-19-27-28-image.png" title="" alt="" data-align="right">

- 마지막 reader가 빠져나가야만 writer가 작업 가능

- starvation 발생 가능 : 리더가 계속 오면 > 기다리는 시간이 길어지면 우선순위 부여

        

### dinin_philosophers 문제

- 5명이 동시에 배가 고파져서 젓가락 한개씩 잡는 경우 데드락

- 왼쪽 사람이 밥을 먹고 오른쪽 사람이 밥을 먹고 왼쪽이 밥을 먹고 반복하면 기아현상

- 문제점 : 데드락 발생

- 해결
  
  - 4명의 철학자만이 테이블에 동시에 앉을 수 있게 한다
  
  - 젓가락을 두 개 모두 집을 수 있을 때에만 잡을 수 있게 설정
  
  - 비대칭 : 짝수는 왼쪽을 홀수는 오른쪽 젓가락을 먼저 잡아야 다른 것도 잡을 수 있도록

![](asd_assets/2023-02-05-19-40-14-image.png)

      

    

### moniter

- 세마포어의 문제점
  
  - 코딩하기 힘들다
  
  - 정확성의 입증이 어렵다
  
  - 자발적 협력이 필요하다
  
  - 한번의 실수가 모든 시스템에 치명적 영향

- 모니터 : 동시 수행중인 프로세스 사이에서 abstract data type의 안전한 공유를 보장하기 위한 high level 동기화 구조

- 모니터 내에서는 한번에 하나의 프로세스만 활동 가능

- 프로그래머가 동기화 제약조건을 명시적으로 코딩할 필요 없음

- 프로세스가 모니터 안에서 기다릴 수 있도록 하기 위해 condition 변수 사용(condition x,y)

- condition은 wait와 signal 연산에 의해서만 접근 가능

- xwait()을 invoke한 프로세스는 다른 프로세스가 x.signal을 invoke하기 전까지 서스펜드 된다

- x.signal()은 정확하게 하나의 서스펜드된 프로세스를 resume한다. 서스펜드가 없으면 아무 일도 일어나지 않는다.

![](asd_assets/2023-02-05-19-51-43-image.png)

- lock을 걸 필요가 없음, 이해가 쉬움(일반적인 프로그래머는 모니터가 더 쉽다)

- 세마포어와 모니터의 코드는 쉽게 서로 전환 가능하다

![](asd_assets/2023-02-05-20-03-25-image.png)

        
